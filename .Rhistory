npv_stats <- rbind(
npv_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_ub = s_lower_bound,
soc_median = s_median,
sco_lb = s_lower_bound
)
)
}
}
mcs_stats(lower_bound = .25, upper_bound = .75)
mcs_stats <- function(lower_bound = 0.25, upper_bound = .75){
# NPV MCS stats
npv_stats <- data.frame(
dr = character(),
prv_lb = numeric(),
prv_median = numeric(),
prv_ub = numeric(),
econ_lb = numeric(),
econ_median = numeric(),
econ_ub = numeric(),
soc_ub = numeric(),
soc_median = numeric(),
sco_lb = numeric(),
stringsAsFactors = FALSE
)
loop_count = ncol(npv_econ_dr)
for (i in 1:loop_count) {
# Extract the values for each discount rate
p_values <- npv_private_dr[,i]
e_values <- npv_econ_dr[,i]
s_values <- npv_social_dr[,i]
# Calculate statistics
p_median <- median(p_values)
p_lower_bound <- quantile(p_values, probs = lower_bound)
p_upper_bound <- quantile(p_values, probs = upper_bound)
e_median <- median(e_values)
e_lower_bound <- quantile(e_values, probs = lower_bound)
e_upper_bound <- quantile(e_values, probs = upper_bound)
s_median <- median(s_values)
s_lower_bound <- quantile(s_values, probs = lower_bound)
s_upper_bound <- quantile(s_values, probs = upper_bound)
# Append results to the results dataframe
npv_stats <- rbind(
npv_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_ub = s_lower_bound,
soc_median = s_median,
sco_lb = s_lower_bound
)
)
}
}
mcs_stats(lower_bound = .25, upper_bound = .75)
mcs_stats <- function(lower_bound = 0.25, upper_bound = .75){
# NPV MCS stats
npv_stats <- data.frame(
dr = character(),
prv_lb = numeric(),
prv_median = numeric(),
prv_ub = numeric(),
econ_lb = numeric(),
econ_median = numeric(),
econ_ub = numeric(),
soc_ub = numeric(),
soc_median = numeric(),
sco_lb = numeric(),
stringsAsFactors = FALSE
)
loop_count = ncol(npv_econ_dr)
for (i in 1:loop_count) {
# Extract the values for each discount rate
p_values <- npv_private_dr[,i]
e_values <- npv_econ_dr[,i]
s_values <- npv_social_dr[,i]
# Calculate statistics
p_median <- median(p_values)
p_lower_bound <- quantile(p_values, probs = lower_bound)
p_upper_bound <- quantile(p_values, probs = upper_bound)
e_median <- median(e_values)
e_lower_bound <- quantile(e_values, probs = lower_bound)
e_upper_bound <- quantile(e_values, probs = upper_bound)
s_median <- median(s_values)
s_lower_bound <- quantile(s_values, probs = lower_bound)
s_upper_bound <- quantile(s_values, probs = upper_bound)
# Append results to the results dataframe
npv_stats <- rbind(
npv_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_ub = s_lower_bound,
soc_median = s_median,
sco_lb = s_lower_bound
)
)
}
assign("npv_stats", npv_stats, envir = .GlobalEnv)
}
mcs_stats(lower_bound = .25, upper_bound = .75)
View(npv_stats)
mcs_stats <- function(lower_bound = 0.25, upper_bound = .75){
# NPV MCS stats
npv_stats <- data.frame(
dr = character(),
prv_lb = numeric(),
prv_median = numeric(),
prv_ub = numeric(),
econ_lb = numeric(),
econ_median = numeric(),
econ_ub = numeric(),
soc_ub = numeric(),
soc_median = numeric(),
sco_lb = numeric(),
stringsAsFactors = FALSE
)
loop_count = ncol(npv_econ_dr)
for (i in 1:loop_count) {
# Extract the values for each discount rate
p_values <- npv_private_dr[,i]
e_values <- npv_econ_dr[,i]
s_values <- npv_social_dr[,i]
# Calculate statistics
p_median <- median(p_values)
p_lower_bound <- quantile(p_values, probs = lower_bound)
p_upper_bound <- quantile(p_values, probs = upper_bound)
e_median <- median(e_values)
e_lower_bound <- quantile(e_values, probs = lower_bound)
e_upper_bound <- quantile(e_values, probs = upper_bound)
s_median <- median(s_values)
s_lower_bound <- quantile(s_values, probs = lower_bound)
s_upper_bound <- quantile(s_values, probs = upper_bound)
# Append results to the results dataframe
npv_stats <- rbind(
npv_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_lb = s_lower_bound,
soc_median = s_median,
sco_ub = s_upper_bound
)
)
}
assign("npv_stats", npv_stats, envir = .GlobalEnv)
}
mcs_stats(lower_bound = .25, upper_bound = .75)
mcs_stats <- function(lower_bound = 0.25, upper_bound = .75){
# NPV MCS stats
npv_stats <- data.frame(
dr = character(),
prv_lb = numeric(),
prv_median = numeric(),
prv_ub = numeric(),
econ_lb = numeric(),
econ_median = numeric(),
econ_ub = numeric(),
soc_ub = numeric(),
soc_median = numeric(),
sco_lb = numeric(),
stringsAsFactors = FALSE
)
loop_count = ncol(npv_econ_dr)
for (i in 1:loop_count) {
# Extract the values for each discount rate
p_values <- npv_private_dr[,i]
e_values <- npv_econ_dr[,i]
s_values <- npv_social_dr[,i]
# Calculate statistics
p_median <- median(p_values)
p_lower_bound <- quantile(p_values, probs = lower_bound)
p_upper_bound <- quantile(p_values, probs = upper_bound)
e_median <- median(e_values)
e_lower_bound <- quantile(e_values, probs = lower_bound)
e_upper_bound <- quantile(e_values, probs = upper_bound)
s_median <- median(s_values)
s_lower_bound <- quantile(s_values, probs = lower_bound)
s_upper_bound <- quantile(s_values, probs = upper_bound)
# Append results to the results dataframe
npv_stats <- rbind(
npv_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_lb = s_lower_bound,
soc_median = s_median,
sco_ub = s_upper_bound
)
)
}
assign("npv_stats", npv_stats, envir = .GlobalEnv)
# LCCA MCS stats
lcca_stats <- data.frame(
dr = character(),
prv_lb = numeric(),
prv_median = numeric(),
prv_ub = numeric(),
econ_lb = numeric(),
econ_median = numeric(),
econ_ub = numeric(),
soc_ub = numeric(),
soc_median = numeric(),
sco_lb = numeric(),
stringsAsFactors = FALSE
)
for (i in 1:loop_count) {
# Extract the values for each discount rate
p_values <- lcca_private_dr[,i]
e_values <- lcca_econ_dr[,i]
s_values <- lcca_social_dr[,i]
# Calculate statistics
p_median <- median(p_values)
p_lower_bound <- quantile(p_values, probs = lower_bound)
p_upper_bound <- quantile(p_values, probs = upper_bound)
e_median <- median(e_values)
e_lower_bound <- quantile(e_values, probs = lower_bound)
e_upper_bound <- quantile(e_values, probs = upper_bound)
s_median <- median(s_values)
s_lower_bound <- quantile(s_values, probs = lower_bound)
s_upper_bound <- quantile(s_values, probs = upper_bound)
# Append results to the results dataframe
lcca_stats <- rbind(
lcca_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_lb = s_lower_bound,
soc_median = s_median,
sco_ub = s_upper_bound
)
)
}
assign("lcca_stats", lcca_stats, envir = .GlobalEnv)
}
mcs_stats(lower_bound = .25, upper_bound = .75)
View(lcca_stats)
rownames(lcca_stats) <- NULL
mcs_stats <- function(lower_bound = 0.25, upper_bound = .75){
# NPV MCS stats
npv_stats <- data.frame(
dr = character(),
prv_lb = numeric(),
prv_median = numeric(),
prv_ub = numeric(),
econ_lb = numeric(),
econ_median = numeric(),
econ_ub = numeric(),
soc_ub = numeric(),
soc_median = numeric(),
sco_lb = numeric(),
stringsAsFactors = FALSE
)
loop_count = ncol(npv_econ_dr)
for (i in 1:loop_count) {
# Extract the values for each discount rate
p_values <- npv_private_dr[,i]
e_values <- npv_econ_dr[,i]
s_values <- npv_social_dr[,i]
# Calculate statistics
p_median <- median(p_values)
p_lower_bound <- quantile(p_values, probs = lower_bound)
p_upper_bound <- quantile(p_values, probs = upper_bound)
e_median <- median(e_values)
e_lower_bound <- quantile(e_values, probs = lower_bound)
e_upper_bound <- quantile(e_values, probs = upper_bound)
s_median <- median(s_values)
s_lower_bound <- quantile(s_values, probs = lower_bound)
s_upper_bound <- quantile(s_values, probs = upper_bound)
# Append results to the results dataframe
npv_stats <- rbind(
npv_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_lb = s_lower_bound,
soc_median = s_median,
sco_ub = s_upper_bound
)
)
}
rownames(npv_stats) <- NULL
assign("npv_stats", npv_stats, envir = .GlobalEnv)
# LCCA MCS stats
lcca_stats <- data.frame(
dr = character(),
prv_lb = numeric(),
prv_median = numeric(),
prv_ub = numeric(),
econ_lb = numeric(),
econ_median = numeric(),
econ_ub = numeric(),
soc_ub = numeric(),
soc_median = numeric(),
sco_lb = numeric(),
stringsAsFactors = FALSE
)
for (i in 1:loop_count) {
# Extract the values for each discount rate
p_values <- lcca_private_dr[,i]
e_values <- lcca_econ_dr[,i]
s_values <- lcca_social_dr[,i]
# Calculate statistics
p_median <- median(p_values)
p_lower_bound <- quantile(p_values, probs = lower_bound)
p_upper_bound <- quantile(p_values, probs = upper_bound)
e_median <- median(e_values)
e_lower_bound <- quantile(e_values, probs = lower_bound)
e_upper_bound <- quantile(e_values, probs = upper_bound)
s_median <- median(s_values)
s_lower_bound <- quantile(s_values, probs = lower_bound)
s_upper_bound <- quantile(s_values, probs = upper_bound)
# Append results to the results dataframe
lcca_stats <- rbind(
lcca_stats,
data.frame(
dr = colnames(npv_econ_dr)[i],
prv_lb = p_lower_bound,
prv_median = p_median,
prv_ub = p_upper_bound,
econ_lb = e_lower_bound,
econ_median = e_median,
econ_ub = e_upper_bound,
soc_lb = s_lower_bound,
soc_median = s_median,
sco_ub = s_upper_bound
)
)
}
rownames(lcca_stats) <- NULL
assign("lcca_stats", lcca_stats, envir = .GlobalEnv)
}
mcs_stats(lower_bound = .25, upper_bound = .75)
#initiate empty dataframe
ref_out <- matrix(0, nrow = run_count, ncol = year_count)
intv_out <- matrix(0, nrow = run_count, ncol = year_count)
boundary_data <- intv_boundary
ref_mean <- 4146
, ref_sd <- 233
ref_sd <- 233
intv_min <- 0.31
intv_max <- 0.47
for (i in 1:run_count) {
for (j in 1:year_count) {
n <- boundary_data[i, j]
# Generate n random numbers based on mean & sd
ref_sim <- rnorm(n, ref_mean, ref_sd)
intv_savings <- runif(n, intv_min, intv_max)
intv_factors <- 1-intv_savings
intv_sim <- ref_sim * intv_factors
# Sum the total activity data
ref_sum <- sum(ref_sim)
intv_sum <- sum(intv_sim)
# Store in respective matrices
ref_out[i, j] <- ref_sum
intv_out[i, j] <- intv_sum
}
}
View(ref_out)
View(boundary_data)
intv_max <- 0.47
intv_min <- 0.31
ref_sd <- 233
ref_mean <- 4146
if (!require("dplyr")) install.packages("dplyr")
library(dplyr)
if (!require("readxl")) install.packages("readxl")
library(readxl)
if (!require("writexl")) install.packages("writexl")
library(writexl)
if (!require("ggplot2")) install.packages("ggplot2")
library(ggplot2)
if (!require("scales")) install.packages("scales")
library(scales)
if (!require("data.table")) install.packages("data.table")
library(data.table)
source("C:/Users/Brand/GitHub/GHG-measure-CBA-via-MCS/parameter_functions.R")
# Define the following global variables to be called by parameter functions
run_count <- 1000
scenario_start <- 2026
scenario_end  <- 2040
year_count <- scenario_end - scenario_start + 1
output_headers <- scenario_start:scenario_end
source("parameter_functions.r")
EFL.co2e("ar6")
write_xlsx(EFL, path = "EFLco2e.xlsx")
scenario.MCS("electricity_ef")
# Reference boundary represents zero energy efficiency upgrades in each year
static.value("ref_boundary", 0)
# Intervention boundary is modeled as a random value between 120 and 160.
discrete.uniform3("intv_boundary", minvalue = 120, maxvalue = 160)
# Project types are randomly assigned for the intervention boundary, with three new dataframes for each project type.
assign.project.type(intv_boundary)
# Calculate cumulative project counts for each project type
ashp_boundary_cumsum <- as.data.frame(t(apply(ashp_count, 1, cumsum)))
weatherize_boundary_cumsum <- as.data.frame(t(apply(weatherize_count, 1, cumsum)))
hpwh_boundary_cumsum <- as.data.frame(t(apply(hpwh_count, 1, cumsum)))
#initiate empty dataframe
ref_out <- matrix(0, nrow = run_count, ncol = year_count)
intv_out <- matrix(0, nrow = run_count, ncol = year_count)
boundary_data <- intv_boundary
View(boundary_data)
boundary_data <- ashp_count
View(boundary_data)
for (i in 1:run_count) {
for (j in 1:year_count) {
n <- boundary_data[i, j]
# Generate n random numbers based on mean & sd
ref_sim <- rnorm(n, ref_mean, ref_sd)
intv_savings <- runif(n, intv_min, intv_max)
intv_factors <- 1-intv_savings
intv_sim <- ref_sim * intv_factors
# Sum the total activity data
ref_sum <- sum(ref_sim)
intv_sum <- sum(intv_sim)
# Store in respective matrices
ref_out[i, j] <- ref_sum
intv_out[i, j] <- intv_sum
}
}
View(ref_boundary)
View(intv_boundary)
View(intv_out)
source("C:/Users/Brand/GitHub/GHG-measure-CBA-via-MCS/parameter_functions.R")
# Define the following global variables to be called by parameter functions
run_count <- 1000
scenario_start <- 2026
scenario_end  <- 2040
year_count <- scenario_end - scenario_start + 1
output_headers <- scenario_start:scenario_end
source("parameter_functions.r")
EFL.co2e("ar6")
write_xlsx(EFL, path = "EFLco2e.xlsx")
scenario.MCS("electricity_ef")
# Reference boundary represents zero energy efficiency upgrades in each year
static.value("ref_boundary", 0)
# Intervention boundary is modeled as a random value between 120 and 160.
discrete.uniform3("intv_boundary", minvalue = 120, maxvalue = 160)
# Project types are randomly assigned for the intervention boundary, with three new dataframes for each project type.
assign.project.type(intv_boundary)
# Calculate cumulative project counts for each project type
ashp_boundary_cumsum <- as.data.frame(t(apply(ashp_count, 1, cumsum)))
weatherize_boundary_cumsum <- as.data.frame(t(apply(weatherize_count, 1, cumsum)))
hpwh_boundary_cumsum <- as.data.frame(t(apply(hpwh_count, 1, cumsum)))
# ASHP factor 1 simulates the annual electricity consumption for space heating and cooling in a residential home
# The intervention factor is also calcualted - ADD MORE
calculate.AD("ashp_ref1", "ashp_intv1", ashp_count, ref_mean = 4146, ref_sd = 233, intv_min = 0.31, intv_max = 0.47, units = "kWh")
source("C:/Users/Brand/GitHub/GHG-measure-CBA-via-MCS/parameter_functions.R")
# ASHP factor 1 simulates the annual electricity consumption for space heating and cooling in a residential home
# The intervention factor is also calcualted - ADD MORE
calculate.AD("ashp_ref1", "ashp_intv1", ashp_count, ref_mean = 4146, ref_sd = 233, intv_min = 0.31, intv_max = 0.47, units = "kWh")
View(ashp_ref1)
View(ashp_intv1)
source("C:/Users/Brand/GitHub/GHG-measure-CBA-via-MCS/parameter_functions.R")
# ASHP factor 2 simulates the annual natural gas consumption for space heating and cooling in a residential home
# The reference factor is simulated for each home based on a normal distribution
# The intervention factor is simulated for each home based on a uniform distribution
# The function outputs total reference and intervention scenario energy consumption for all homes in boundary
calculate.AD1("ashp_ref2", "ashp_intv2", ashp_count, ref_mean = 603, ref_sd = 11.3, intv_min = 0.31, intv_max = 0.47, units = "therms")
View(ashp_ref2)
View(ashp_intv2)
runif(10, min = 2100, max = 6000)
runif(0, min = 2100, max = 6000)
sum(runif(0, min = 2100, max = 6000))
source("C:/Users/Brand/GitHub/GHG-measure-CBA-via-MCS/parameter_functions.R")
# ASHP Capex is calculated by simulating the installation costs for each home
calculate.capex("ashp_refcapex", "ashp_intvcapex", ref_boundary, ashp_count, capex_min = 2100, capex_max = 6000, units = "USD")
View(ashp_refcapex)
View(ashp_intvcapex)
View(ashp_count)
source("C:/Users/Brand/GitHub/GHG-measure-CBA-via-MCS/parameter_functions.R")
# ASHP Capex is calculated by simulating the installation costs for each home
calculate.capex("ashp_refcapex", "ashp_intvcapex", ref_boundary, ashp_count, capex_min = 2100, capex_max = 6000, units = "USD")
View(ashp_intvcapex)
