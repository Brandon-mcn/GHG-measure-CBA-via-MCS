geom_line(size = .5) +
geom_ribbon(aes(ymin = lb1, ymax = ub1), alpha = 0.25, color = NA) +
geom_ribbon(aes(ymin = lb2, ymax = ub2), alpha = 0.4, color = NA) +
labs(title = "b",
x = "Year",
y = "Million BTUs") +
scale_y_continuous(labels = comma, breaks = scales::breaks_extended(n = 6)) +
scale_x_continuous(
breaks = seq(scenario_start, scenario_end, by = 5),
labels = seq(scenario_start, scenario_end, by = 5)) +
theme_minimal() +
scale_color_manual(values = c("Reference Scenario" = "deepskyblue4", "Intervention Scenario" = "palegreen4")) +
scale_fill_manual(values = c("Reference Scenario" = "deepskyblue4", "Intervention Scenario" = "palegreen4")) +
theme(text = element_text(size = 8, color = "black"),
plot.title = element_text(face = "bold", size = 12, color = "black"),
axis.text = element_text(size = 8, color = "black"),
axis.title = element_text(size = 8, color = "black"),
legend.text = element_text(size = 8, color = "black"),
axis.ticks = element_line(color = "black", size = .5),
axis.line = element_line(color = "black", size = .5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
aspect.ratio = 1)
p1 <- p_mwh + p_mmbtu + plot_layout(guides = 'collect')
ggsave("figures/fig3.png", plot = p1, width = 6.5, height = 2.5, dpi = 300)
# Electricity scenarios
elec_ef_scenarios <- read_excel("scenarios.xlsx", sheet = "electricity_ef")
fig4_trim <- cbind(elec_ef_scenarios[, 3], elec_ef_scenarios[, 9:34])
fig4_data <- fig4_trim %>%
pivot_longer(cols = starts_with("20"),
names_to = "year",
values_to = "value")
fig4_data$year <- as.numeric(fig4_data$year)
colnames(fig4_data)[1] <- "scenario"
p4_scenario_order <- c("Mid-case",
"Low Renewable Energy Costs",
"High Renewable Energy Costs",
"Low Natural Gas Prices",
"High Natural Gas Prices",
"High Demand Growth",
"95% Decarbonization by 2050",
"100% Decarbonization by 2035")
p4_colors <- c(
"Mid-case" = "#1F77B4",  # Blue
"Low Renewable Energy Costs" = "#FF7F0E",  # Orange
"High Renewable Energy Costs" = "#2CA02C",  # Green
"Low Natural Gas Prices" = "#D62728",  # Red
"High Natural Gas Prices" = "#9467BD",  # Purple
"High Demand Growth" = "#8C564B",  # Brown
"95% Decarbonization by 2050" = "#E377C2",  # Light Purple
"100% Decarbonization by 2035" = "#7F7F7F"  # Gray
)
p4 <- ggplot(fig4_data, aes(x = year, y = value, color = scenario, group = scenario)) +
geom_line(size = 1) +
labs(title = NULL,
x = "Year", y = "kgco2e/kWh", color = "Scenario") +
scale_color_manual(
values = p4_colors,
breaks = p4_scenario_order) +
theme_minimal() +
theme(text = element_text(size = 8, color = "black"),
plot.title = element_text(face = "bold", size = 12, color = "black"),
axis.text = element_text(size = 8, color = "black"),
axis.title = element_text(size = 8, color = "black"),
legend.text = element_text(size = 8, color = "black"),
axis.ticks = element_line(color = "black", size = .5),
axis.line = element_line(color = "black", size = .5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
aspect.ratio = .5,
legend.position = "right")
ggsave("figures/fig2.png", plot = p4, width = 6.5, height = 2.5, dpi = 300)
ggsave("figures/fig6.png", plot = p5, width = 6.5, height = 6.5, dpi = 300)
cba_social_plot("lcca_social_plot", lcca_stats, c = "orangered4", ylab = NULL, xlab = expression(atop("r"[e], "\nSocial Boundary")), panel = "f")
p5 <- npv_econ_plot + npv_social_plot + sroi_econ_plot + sroi_social_plot + lcca_econ_plot + lcca_social_plot +
plot_layout(ncol = 2, nrow = 3)
ggsave("figures/fig6.png", plot = p5, width = 6.5, height = 6.5, dpi = 300)
View(intv_boundary_mgnl)
View(intv_mwh)
View(ashp_intv_data1)
# GHG mitigation
sens_ghg <- as.data.frame(p_count =  rowsum(intv_boundary_mgnl),
ashp_ref_kwh = rowsum(ashp_intv_ann_data1[,-1]))
sens_ghg <- data.frame(p_count =  rowsum(intv_boundary_mgnl),
ashp_ref_kwh = rowsum(ashp_intv_ann_data1[,-1]))
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]))
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]))
View(sens_ghg)
# GHG mitigation
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]),
weather_ref_kwh = rowSums(weatherize_intv_ann_data1[,-1]),
hwhp_ref_kwh = rowSums(hpwh_intv_ann_data1[,-1]))
View(ghg_mit)
# GHG mitigation
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]),
weather_ref_kwh = rowSums(weatherize_intv_ann_data1[,-1]),
hwhp_ref_kwh = rowSums(hpwh_intv_ann_data1[,-1]),
ashp_ref_therms = rowSums(ashp_intv_ann_data2[,-1]),
weather_ref_therms = rowSums(weatherize_intv_ann_data2[,-1]),
hwhp_ref_therms = rowSums(hpwh_intv_ann_data2[,-1]),
ghg_mit = ghg_mit)
# GHG mitigation
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]),
weather_ref_kwh = rowSums(weatherize_intv_ann_data1[,-1]),
hwhp_ref_kwh = rowSums(hpwh_intv_ann_data1[,-1]),
ashp_ref_therms = rowSums(ashp_intv_ann_data2[,-1]),
weather_ref_therms = rowSums(weatherize_intv_ann_data2[,-1]),
hwhp_ref_therms = rowSums(hpwh_intv_ann_data2[,-1]),
ghg_mit1 = ghg_mit)
# GHG mitigation
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]),
weather_ref_kwh = rowSums(weatherize_intv_ann_data1[,-1]),
hwhp_ref_kwh = rowSums(hpwh_intv_ann_data1[,-1]),
ashp_ref_therms = rowSums(ashp_intv_ann_data2[,-1]),
weather_ref_therms = rowSums(weatherize_intv_ann_data2[,-1]),
hwhp_ref_therms = rowSums(hpwh_intv_ann_data2[,-1]),
ghg_mit = unname(ghg_mit))
install.packages("pse")  # If not installed
install.packages("pse")  # If not installed
library(pse)
library(pse)
install.packages("Hmisc")  # If not installed
library(Hmisc)
prcc_results <- rcorr(as.matrix(inputs), outputs, type = "spearman")  # Spearman's Rank Correlation
inputs <- sens_ghg[, 1:7]  # Model parameters (adjust column range)
outputs <- sens_ghg[, 8]   # The final column is the emissions reduction result
prcc_results <- rcorr(as.matrix(inputs), outputs, type = "spearman")  # Spearman's Rank Correlation
print(prcc_results$r)  # Display correlation coefficients
install.packages("sensitivity")
library(sensitivity)
prcc_results2 <- sensitivity::morris(model = NULL, factors = colnames(inputs), r = 1000, design = list(type = "oat", levels = 4, grid.jump = 2))
print(sobol_results)
prcc_results2 <- sensitivity::morris(model = NULL, factors = colnames(inputs), r = 1000, design = list(type = "oat", levels = 4, grid.jump = 2))
print(sobol_results)
print(morris_results)
# Convert inputs to a matrix (one row per trial, columns for each parameter)
inputs_matrix <- as.matrix(inputs)
# Apply Sobol Sensitivity Analysis
sobol_results <- sobolSaltelli(model = NULL, X1 = inputs_matrix, X2 = inputs_matrix, nboot = 100)
library(sensitivity)
# Convert inputs to a matrix (one row per trial, columns for each parameter)
inputs_matrix <- as.matrix(inputs)
# Apply Sobol Sensitivity Analysis
sobol_results <- sobolSaltelli(model = NULL, X1 = inputs_matrix, X2 = inputs_matrix, nboot = 100)
# Apply Sobol Sensitivity Analysis
sobol_results <- sobol(model = NULL, X1 = inputs_matrix, y = output, nboot = 100)
# Convert inputs to a matrix (one row per trial, columns for each parameter)
inputs_matrix <- as.matrix(inputs)
morris_results <- morris(model = NULL, factors = colnames(inputs_matrix),
r = 1000, design = list(type = "oat", levels = 4, grid.jump = 2))
# View Morris results
print(morris_results)  # View the elementary effects
print(morris_results$ee)  # Mean elementary effects (μ)
print(morris_results$se)  # Standard deviation of effects (σ)
plot(morris_results)  # Visualize Morris sensitivity
prcc_results <- rcorr(as.matrix(inputs), outputs, type = "spearman")  # Spearman's Rank Correlation
print(prcc_results$r)
X2 <- inputs + matrix(rnorm(length(inputs), mean = 0, sd = 0.1), nrow = nrow(inputs), ncol = ncol(inputs))
# Perform Sobol sensitivity analysis
sobol_results <- sobol(model = NULL, X1 = inputs, X2 = X2, y = output, nboot = 100)
# First-order Sobol indices (direct effect of each variable)
sobol_first_order <- sobol_results$S
sobol_first_order
# Perform Sobol sensitivity analysis
sobol_results <- sobol(model = NULL, X1 = inputs, X2 = X2, y = output, nboot = 100)
# First-order Sobol indices (direct effect of each variable)
sobol_first_order <- sobol_results$S
sobol_first_order
sobol_results$S
install.packages("randomForest")
install.packages("randomForest")
install.packages("randomForest")
# Fit a random forest model
rf_model <- randomForest(inputs, output, importance = TRUE)
library(randomForest)
# Fit a random forest model
rf_model <- randomForest(inputs, output, importance = TRUE)
inputs <- sens_ghg[, 1:(ncol(sens_ghg) - 1)]  # Model parameters (adjust column range)
outputs <- sens_ghg[, ncol(sens_ghg)]   # The final column is the emissions reduction result
# Sobol
X2 <- inputs + matrix(rnorm(length(inputs), mean = 0, sd = 0.1), nrow = nrow(inputs), ncol = ncol(inputs))
# Perform Sobol sensitivity analysis
sobol_results <- sobol(model = NULL, X1 = inputs, X2 = X2, y = outputs, nboot = 100)
# First-order Sobol indices (direct effect of each variable)
sobol_first_order <- sobol_results$S
sobol_first_order
# Install and load randomForest
install.packages("randomForest")
# Perform Sobol sensitivity analysis
sobol_results <- sobol(model = NULL, X1 = inputs, X2 = X2, y = outputs, nboot = 100)
# Fit a random forest model
rf_model <- randomForest(inputs, output, importance = TRUE)
# Fit a random forest model
rf_model <- randomForest(inputs, outputs, importance = TRUE)
# Fit a random forest model
rf_model <- randomForest(inputs, outputs, importance = TRUE)
prcc_results <- rcorr(as.matrix(inputs), outputs, type = "spearman")  # Spearman's Rank Correlation
print(prcc_results$r)
mwh_savings <- ref_mwh - intv_mwh
rf_importance
# Get feature importance scores
rf_importance <- importance(rf_model)
rf_importance
# First-order Sobol indices (direct effect of each variable)
sobol_first_order <- sobol_results$S
sobol_first_order
# Sobol
X2 <- inputs + matrix(rnorm(length(inputs), mean = 0, sd = 0.1), nrow = nrow(inputs), ncol = ncol(inputs))
View(X2)
# Perform Sobol sensitivity analysis
sobol_results <- sobol(model = NULL, X1 = inputs, X2 = X2, y = outputs, nboot = 100)
View(sobol_results)
# First-order Sobol indices (direct effect of each variable)
sobol_first_order <- sobol_results$S
sobol_first_order
outputs <- sens_ghg[, ncol(sens_ghg)]   # The final column is the emissions reduction result
inputs_matrix <- as.matrix(inputs)
output_matrix <- as.matrix(output)
output <- sens_ghg[, ncol(sens_ghg)]   # The final column is the emissions reduction result
output_matrix <- as.matrix(output)
# Sobol
X2 <- inputs_matrix + matrix(rnorm(length(inputs_matrix), mean = 0, sd = 0.1), nrow = nrow(inputs_matrix), ncol = ncol(inputs_matrix))
# Perform Sobol sensitivity analysis
sobol_results <- sobol(model = NULL, X1 = inputs_matrix, X2 = X2, y = output_matrix, nboot = 100)
# First-order Sobol indices (direct effect of each variable)
sobol_first_order <- sobol_results$S
sobol_first_order
str(sobol_results)
?sobol
sobol_results
# Define the Morris method
morris_results <- morris(model = NULL, factors = colnames(inputs),
r = 1000, design = list(type = "oat", levels = 4, grid.jump = 2))
# View Morris results
morris_results$ee  # Mean elementary effects (μ)
morris_results$se  # Standard deviation of effects (σ)
correlation_matrix <- cor(inputs, output, method = "pearson")
correlation_matrix
rf_importance
install.packages("xgboost")
install.packages("shap")
library(xgboost)
library(shap)
install.packages("fastshap")
# Fit an XGBoost model
xgb_model <- xgboost(data = as.matrix(inputs), label = output, nrounds = 100)
# Fit an XGBoost model
xgb_model <- xgboost(data = output_matix, label = inputs_matrix, nrounds = 100, objective = "multi:softmax", num_class = 3)
# Fit an XGBoost model
xgb_model <- xgboost(data = output_matrix, label = inputs_matrix, nrounds = 100, objective = "multi:softmax", num_class = 3)
# Fit an XGBoost model
xgb_model <- xgboost(data = as.matrix(inputs), label = output, nrounds = 100)
# Compute SHAP values
shap_values <- fastshap::shap.compute(xgb_model, inputs)
# Compute SHAP values
shap_values <- fastshap::shap.compute(xgb_model, inputs)
# Compute SHAP values
shap_values <- fastshap::shap(xgb_model, inputs)
# Compute SHAP values
shap_values <- fastshap::fastshap(xgb_model, inputs)
sobol_result <- sobol(model = NULL, X1 = inputs, y = output, nboot = 100)
View(X2)
x2sobol <- X2
sobol_result <- sobol(model = NULL, X1 = inputs, X2 = x2sobol, y = output, nboot = 100)
View(sobol_result)
print(sobol_result)
sobol_result <- sobol(model = NULL, X1 = inputs, X2 = x2sobol, y = output, nboot = 100)
print(sobol_result)
result <- sobol(model = NULL, X1 = inputs, X2 = x2sobol, y = output, nboot = 100)
print(result)
result <- sobol(model = NULL, X1 = inputs_matrix, X2 = x2sobol, y = output_matrix, nboot = 100)
print(result)
output_matrix <- as.matrix(output)
output <- sens_ghg[, ncol(sens_ghg)]   # The final column is the emissions reduction result
result <- sobol(model = NULL, X1 = inputs_matrix, X2 = x2sobol, y = output, nboot = 100)
print(result)
X <- as.matrix(inputs)
y <- as.numeric(output)
sobol_result <- sobolSalt(model = NULL, X1 = X, X2 = X, nboot = 100)
sobol_result$y <- y
tell(sobol_result, y)
print(sobol_result)
sobol_result <- sobolSalt(model = NULL, X1 = X, X2 = X, nboot = 100)
sobol_result$y <- y
sobol_result <- sobolSalt(model = NULL, X1 = Xs, X2 = Xs, nboot = 100)
Xs <- as.matrix(inputs)
ys <- as.numeric(output)
sobol_result <- sobolSalt(model = NULL, X1 = Xs, X2 = Xs, nboot = 100)
sobol_result$y <- ys
tell(sobol_result, ys)
X <- as.matrix(inputs)
X <- as.matrix(inputs)
y <- as.numeric(output)
sobol_result <- sobolSalt(model = NULL, X1 = X, X2 = X, nboot = 100)
sobol_result$y <- y
tell(sobol_result, y)
print(dim(sobol_result$X))
# Compute PCC (correlation of each input with output while controlling for others)
pcc_results <- pcor(cbind(inputs, output))$estimate
# PCC
install.packages("ppcor")
# PCC
install.packages("ppcor")
library(ppcor)
# Compute PCC (correlation of each input with output while controlling for others)
pcc_results <- pcor(cbind(inputs, output))$estimate
# Extract the last row (correlations between inputs and output)
pcc_values <- pcc_results[nrow(pcc_results), -ncol(pcc_results)]
# Print PCC values
print(pcc_values)
barplot(abs(pcc_values), names.arg = colnames(X), las = 2, col = "blue", main = "Partial Correlation Coefficients (PCC)")
# Load necessary package
install.packages("boot")
# Load necessary package
library(boot)
# Fit a linear regression model using inputs to predict the output
lm_model <- lm(output ~ ., data = sens_ghg)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(Y)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(output)
# Print SRC values (higher absolute values mean more influence)
print(src)
# Fit a linear regression model using inputs to predict the output
lm_model <- lm(output ~ ., data = sens_ghg)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(output)
# Print SRC values (higher absolute values mean more influence)
print(src_values)
# Print PCC values
print(pcc_values)
barplot(abs(pcc_values), names.arg = colnames(X), las = 2, col = "blue", main = "Partial Correlation Coefficients (PCC)")
barplot(abs(src_values), names.arg = colnames(X), las = 2, col = "blue", main = "Standardized Regression Coefficients (SRC)")
barplot(abs(src_values), names.arg = colnames(X), las = 2, col = "blue", main = "Standardized Regression Coefficients (SRC)")
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]),
weather_ref_kwh = rowSums(weatherize_intv_ann_data1[,-1]),
hwhp_ref_kwh = rowSums(hpwh_intv_ann_data1[,-1]),
ashp_ref_therms = rowSums(ashp_intv_ann_data2[,-1]),
weather_ref_therms = rowSums(weatherize_intv_ann_data2[,-1]),
hwhp_ref_therms = rowSums(hpwh_intv_ann_data2[,-1]),
ghg_mit = unname(ghg_mit))
inputs <- sens_ghg[, 1:(ncol(sens_ghg) - 1)]  # Model parameters (adjust column range)
output <- sens_ghg[, ncol(sens_ghg)]   # The final column is the emissions reduction result
library(Hmisc)
prcc_results <- rcorr(as.matrix(inputs), outputs, type = "spearman")  # Spearman's Rank Correlation
print(prcc_results$r)
correlation_matrix <- cor(inputs, output, method = "pearson")
correlation_matrix
print(correlation_matrix)
print(prcc_results$r)
print(correlation_matrix$y)
print(correlation_matrix$y)
rf_importance
long_data <- pivot_longer(sens_ghg, cols = -ghg_mit, names_to = "Variable", values_to = "Value")
# Create scatterplots with ggplot2
ggplot(long_data, aes(x = Value, y = ghg_mit)) +
geom_point(alpha = 0.5, color = "blue") +  # Scatter points
geom_smooth(method = "lm", color = "red", se = FALSE) +  # Add trend line
facet_wrap(~Variable, scales = "free_x") +  # Separate by variable
labs(title = "Scatterplots of Input Variables vs Output") +
theme_minimal()
# Rank variables by absolute SRC value
ranked_src <- sort(abs(src_values), decreasing = TRUE)
# Print ranked variables
print(ranked_src)
# Rank variables by absolute SRC value
ranked_src <- sort(abs(src_values), decreasing = TRUE)
# Print ranked variables
print(ranked_src)
# Fit a linear regression model using inputs to predict the output
lm_model <- lm(output ~ ., data = sens_ghg)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(output)
# Rank variables by absolute SRC value
ranked_src <- sort(abs(src_values), decreasing = TRUE)
# Print ranked variables
print(ranked_src)
# Compute PCC (correlation of each input with output while controlling for others)
pcc_results <- pcor(cbind(inputs, output))$estimate
# Extract the last row (correlations between inputs and output)
pcc_values <- pcc_results[nrow(pcc_results), -ncol(pcc_results)]
# Print PCC values
print(pcc_values)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(output)
# Print ranked variables
print(src_values)
sim_results <- data.frame(
Var1 = runif(100, 1, 10),
Var2 = runif(100, 5, 15),
Var3 = runif(100, 10, 20),
Var4 = runif(100, 0, 5),
Var5 = runif(100, 2, 8),
Var6 = runif(100, 3, 12),
Var7 = runif(100, 1, 7)
)
# Define an output variable that depends on the inputs
sim_results$Output <- 3*sim_results$Var1 - 2*sim_results$Var2 + 1.5*sim_results$Var3 +
0.5*sim_results$Var4 - 1.2*sim_results$Var5 + 2*sim_results$Var6 +
rnorm(100, mean = 0, sd = 2)  # Adding some noise
# Extract input variables (all columns except the last one)
X <- sim_results[, -ncol(sim_results)]
# Extract output variable (last column)
Y <- sim_results$Output
# Fit linear regression model
lm_model <- lm(Y ~ ., data = sim_results)
# Compute SRC: Standardize by multiplying each coefficient by (SD of X) / (SD of Y)
src_values <- coef(lm_model)[-1] * apply(X, 2, sd) / sd(Y)
# Rank variables by absolute SRC value
ranked_src <- sort(abs(src_values), decreasing = TRUE)
# Print ranked variables with SRC values
print(ranked_src)
barplot(abs(ranked_src), names.arg = names(ranked_src), las = 2, col = "blue",
main = "Standardized Regression Coefficients (SRC)", ylab = "Absolute SRC Value")
# Fit a linear regression model using inputs to predict the output
lm_model <- lm(output ~ ., data = inputs)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(output)
# Rank variables by absolute SRC value
ranked_src <- sort(abs(src_values), decreasing = TRUE)
# Print ranked variables
print(ranked_src)
prcc_results <- rcorr(as.matrix(inputs), outputs, type = "spearman")  # Spearman's Rank Correlation
print(prcc_results$r)
# Compute PCC (correlation of each input with output while controlling for others)
pcc_results <- pcor(cbind(inputs, output))$estimate
# Extract the last row (correlations between inputs and output)
pcc_values <- pcc_results[nrow(pcc_results), -ncol(pcc_results)]
# Print PCC values
print(pcc_values)
# Convert SRC results into a data frame
src_df <- data.frame(Variable = names(ranked_src), SRC = ranked_src)
ggplot(src_df, aes(x = reorder(Variable, SRC), y = SRC)) +
geom_segment(aes(xend = Variable, yend = 0), color = "gray") +  # Line from y = 0 to y = SRC
geom_point(size = 4, color = "blue") +  # Point at the end of the line
coord_flip() +  # Flip to horizontal layout
labs(title = "Variable Importance (SRC)", x = "Variable", y = "SRC Value") +
theme_minimal()
sens_ghg <- data.frame(p count =  rowSums(intv_boundary_mgnl[,-1]),
# GHG mitigation
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ashp_ref_kwh = rowSums(ashp_intv_ann_data1[,-1]),
weather_ref_kwh = rowSums(weatherize_intv_ann_data1[,-1]),
hwhp_ref_kwh = rowSums(hpwh_intv_ann_data1[,-1]),
ashp_ref_therms = rowSums(ashp_intv_ann_data2[,-1]),
weather_ref_therms = rowSums(weatherize_intv_ann_data2[,-1]),
hwhp_ref_therms = rowSums(hpwh_intv_ann_data2[,-1]),
ghg_mit = unname(ghg_mit))
inputs <- sens_ghg[, 1:(ncol(sens_ghg) - 1)]  # Model parameters (adjust column range)
output <- sens_ghg[, ncol(sens_ghg)]   # The final column is the emissions reduction result
# Load necessary package for Standardized Regression Coefficients (SRC)
library(boot)
# Fit a linear regression model using inputs to predict the output
lm_model <- lm(output ~ ., data = inputs)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(output)
# Rank variables by absolute SRC value
ranked_src <- sort(abs(src_values), decreasing = TRUE)
# Print ranked variables
print(ranked_src)
# Convert SRC results into a data frame
src_df <- data.frame(Variable = names(ranked_src), SRC = ranked_src)
ggplot(src_df, aes(x = reorder(Variable, SRC), y = SRC)) +
geom_segment(aes(xend = Variable, yend = 0), color = "gray") +  # Line from y = 0 to y = SRC
geom_point(size = 4, color = "blue") +  # Point at the end of the line
coord_flip() +  # Flip to horizontal layout
labs(title = "Variable Importance (SRC)", x = "Variable", y = "SRC Value") +
theme_minimal()
View(ref_mwh)
ashp_savings <- (ashp_intv_ann_data1[,-1] - ashp_ref_ann_data1[,-1]) / ashp_ref_ann_data1[,-1]
View(ashp_savings)
ashp_savings <- (rowSums(ashp_intv_ann_data1[,-1]) - rowSums(ashp_ref_ann_data1[,-1])) / rowSums(ashp_intv_ann_data1[,-1])
ashp_savings <- (rowSums(ashp_intv_ann_data1[,-1]) - rowSums(ashp_ref_ann_data1[,-1])) / rowSums(ashp_ref_ann_data1[,-1]
ashp_savings <- (rowSums(ashp_intv_ann_data1[,-1]) - rowSums(ashp_ref_ann_data1[,-1])) / rowSums(ashp_ref_ann_data1[,-1]
ashp_savings <- (rowSums(ashp_intv_ann_data1[,-1]) - rowSums(ashp_ref_ann_data1[,-1])) / rowSums(ashp_ref_ann_data1[,-1])
ashp_savings <- -1 * (rowSums(ashp_intv_ann_data1[,-1]) - rowSums(ashp_ref_ann_data1[,-1])) / rowSums(ashp_ref_ann_data1[,-1])
ashp_savings
source("C:/Users/Brand/GitHub/GHG-measure-CBA-via-MCS/parameter_functions.R")
weatherize_savings <- -1 * (rowSums(weatherize_intv_ann_data1[,-1]) - rowSums(weatherize_ref_ann_data1[,-1])) / rowSums(weatherize_ref_ann_data1[,-1])
hpwh_savings <- -1 * (rowSums(hpwh_intv_ann_data1[,-1]) - rowSums(hpwh_ref_ann_data1[,-1])) / rowSums(hpwh_ref_ann_data1[,-1])
sens_ghg <- data.frame(p_count =  rowSums(intv_boundary_mgnl[,-1]),
ref_mwh = rowSums(ref_mwh),
ref_mmbtu = rowSums(ref_mmbtu),
ashp_savings = ashp_savings,
weatherize_savings = weatherize_savings,
hpwh_savings = hpwh_savings,
ghg_mit = unname(ghg_mit))
inputs <- sens_ghg[, 1:(ncol(sens_ghg) - 1)]  # Model parameters (adjust column range)
output <- sens_ghg[, ncol(sens_ghg)]   # The final column is the emissions reduction result
# Fit a linear regression model using inputs to predict the output
lm_model <- lm(output ~ ., data = inputs)
# Compute standardized regression coefficients (SRC)
src_values <- coef(lm_model)[-1] * apply(inputs, 2, sd) / sd(output)
# Rank variables by absolute SRC value
ranked_src <- sort(abs(src_values), decreasing = TRUE)
# Print ranked variables
print(ranked_src)
# Convert SRC results into a data frame
src_df <- data.frame(Variable = names(ranked_src), SRC = ranked_src)
ggplot(src_df, aes(x = reorder(Variable, SRC), y = SRC)) +
geom_segment(aes(xend = Variable, yend = 0), color = "gray") +  # Line from y = 0 to y = SRC
geom_point(size = 4, color = "blue") +  # Point at the end of the line
coord_flip() +  # Flip to horizontal layout
labs(title = "Variable Importance (SRC)", x = "Variable", y = "SRC Value") +
theme_minimal()
